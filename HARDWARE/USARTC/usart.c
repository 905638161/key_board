
#include "usart.h"
#include "datahandle.h"

u8  Uart5TxBuffer[14] = {0};
u8 	Uart5RxBuffer[30] = {0};


u8 	Uart4RxBuffer[30] = {0};

u8  Uart2TxBuffer[14] = {0};
u8 	Uart2RxBuffer[14] = {0};

/*---------------------------- USART2 Mode Configuration -----------------------*/
/**
  * @brief  USART2 ≥ı ºªØ£¨USART2Ω¯––¡À÷ÿ”≥…‰£¨“Ú¥À–Ë“™≥ı ºªØUSART1¬‘”–≤ªÕ¨
  * @param  baud: Set the communication baud rate 4800
  * @details —™—ıƒ£øÈÕ®–≈¥Æø⁄,≤®Ãÿ¬ Œ™4800,∆Ê–£—È
  * @retval None
  */
void USART2_Init(u32 baud)
{
    //GPIO∂Àø⁄…Ë÷√
    GPIO_InitTypeDef  GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef  NVIC_InitStructure;


    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	// πƒ‹USART2
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);	// πƒ‹GPIOD,ø™∆Ù∏¥”√ ±÷”
    USART_DeInit(USART2);  //∏¥Œª¥Æø⁄2

    /*Ω¯––USART2µƒ÷ÿ”≥…‰≈‰÷√*/
   // GPIO_PinRemapConfig  (GPIO_Remap_USART2, ENABLE);

    /*USART2_TX   PA.2*/
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; 
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//∏¥”√Õ∆ÕÏ ‰≥ˆ
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    /*USART2_RX   PA.3*/
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//∏°ø’ ‰»Î
    GPIO_Init(GPIOA, &GPIO_InitStructure);  //≥ı ºªØPD6

//    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //…Ë÷√÷–∂œ◊È2£¨0-3«¿’º”≈œ»º∂£¨0-3œÏ”¶”≈œ»º∂£ª


    NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3 ; //«¿’º”≈œ»º∂3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//◊””≈œ»º∂3
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQÕ®µ¿ πƒ‹
    NVIC_Init(&NVIC_InitStructure);	//∏˘æ›÷∏∂®µƒ≤Œ ˝≥ı ºªØVICºƒ¥Ê∆˜

    //USART≥ı ºªØ…Ë÷√

    USART_InitStructure.USART_BaudRate = baud;//≤®Ãÿ¬ µƒ…Ë÷√
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;//◊÷≥§Œ™8Œª ˝æ›∏Ò Ω
    USART_InitStructure.USART_StopBits = USART_StopBits_1;//“ª∏ˆÕ£÷πŒª
    USART_InitStructure.USART_Parity = USART_Parity_No ; //Œﬁ–£—ÈŒª£
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//Œﬁ”≤º˛ ˝æ›¡˜øÿ÷∆
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	// ’∑¢ƒ£ Ω

    USART_Init(USART2, &USART_InitStructure); //≥ı ºªØ¥Æø⁄
    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//ø™∆Ù÷–∂œ
    USART_Cmd(USART2, ENABLE);                    // πƒ‹¥Æø⁄
}

/**
  * @brief  Transmits single data through the USART2 peripheral.
  * @param  Data£∫The data to transmit.
  * @retval None
  */
void USART2_Send_Byte(u8 Data) //∑¢ÀÕ“ª∏ˆ◊÷Ω⁄£ª
{
    USART_SendData(USART2, Data);
    while( USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET );
}
/**
  * @brief  Transmits  string data through the USART2 peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART2_Send_String(u8 *Data) //∑¢ÀÕ◊÷∑˚¥Æ£ª
{
    while(*Data)
        USART2_Send_Byte(*Data++);
}

void USART2_Data_Transmit(void)
{
		USART_ITConfig(USART2, USART_IT_TXE,ENABLE); 
}

/**
  * @brief  USART2 interrupt handing function.
  * @param  None
  * @details ∂‘ ’µΩµƒ ˝æ›Ω¯––≥ı≤Ωµƒ¥¶¿Ì£¨≥ıº∂º”π§
			 —™—ıƒ£øÈ∑¢ÀÕµƒ ˝æ›”–5∏ˆ◊÷Ω⁄
  * @retval None
  */
void USART2_IRQHandler(void) //÷–∂œ¥¶¿Ì∫Ø ˝;
{
    static u8 	LastData = 0;
    static u16	Wait_Syn = TRUE;
    static u8		Rx_num = 0;
    static u8   Tx_num = 0;
    u8 data = 0;
		
    if(USART_GetITStatus(USART2, USART_IT_RXNE) == SET) //≈–∂œ «∑Ò∑¢…˙÷–∂œ;
    {
        USART_ClearFlag(USART2, USART_IT_RXNE); //«Â≥˝±Í÷æŒª£ª
        if (Wait_Syn == TRUE)  				  //≈–∂œ∆ º±Í÷æ0xaa,0x55, «∑ÒÕÍ≥…
        {
            data = USART_ReceiveData(USART2); //Ω” ’ ˝æ›£ª
            if((LastData == '$') && (data == '@'))
            {
                Wait_Syn = FALSE;
            }
            LastData = data;
						Rx_num = 0;
        }
        else
        {
            Uart2RxBuffer[Rx_num++] = USART_ReceiveData(USART2);
            if(Rx_num >= 3)
            {
								Uart2_RecvDataProcess(Uart2RxBuffer);
								Rx_num = 0;
								LastData = 0;
								Wait_Syn = TRUE;
            }
        }
    }
		else if(USART_GetITStatus(USART2,USART_IT_TXE) != RESET)	//send data interupt
		{
				if(Tx_num < 5)
				{	
						USART_SendData(USART2,Uart2TxBuffer[Tx_num]);
						Tx_num++;	
				}
				else
				{	
						Tx_num=0;
						USART_ITConfig(USART2, USART_IT_TXE,DISABLE);
						if(Inquire_TXD_Handler(USART2))
						{
								UART2_TX_BUSY_FLAG = FALSE;
						}
				}
		}
}

/*---------------------------- UART4 Mode Configuration -----------------------*/
/**
  * @brief  UART4≥ı ºªØ PC10,PC11
  * @param  baud: Set the communication baud rate
  * @retval None
  */
void UART4_Init(u32 baud)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE );
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE );

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //UART4 TX£ª
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //∏¥”√Õ∆ÕÏ ‰≥ˆ£ª
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOC, &GPIO_InitStructure); //∂Àø⁄C£ª

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; //UART4 RX£ª
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //∏°ø’ ‰»Î£ª
    GPIO_Init(GPIOC, &GPIO_InitStructure); //∂Àø⁄C£ª

    USART_InitStructure.USART_BaudRate = baud; //≤®Ãÿ¬ £ª
    USART_InitStructure.USART_WordLength = USART_WordLength_8b; // ˝æ›Œª8Œª£ª
    USART_InitStructure.USART_StopBits = USART_StopBits_1; //Õ£÷πŒª1Œª£ª
    USART_InitStructure.USART_Parity = USART_Parity_No ; //Œﬁ–£—ÈŒª£ª
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//Œﬁ”≤º˛¡˜øÿ£ª
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;// ’∑¢ƒ£ Ω£ª
    USART_Init(UART4, &USART_InitStructure);//≈‰÷√¥Æø⁄≤Œ ˝£ª

//    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //…Ë÷√÷–∂œ◊È2£¨0-3«¿’º”≈œ»º∂£¨0-3œÏ”¶”≈œ»º∂£ª

    NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn; //÷–∂œ∫≈£ª
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //«¿’º”≈œ»º∂£ª
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //œÏ”¶”≈œ»º∂£ª
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

    USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    USART_Cmd(UART4, ENABLE); // πƒ‹¥Æø⁄£ª
}
/**
  * @brief  Transmits single data through the UART4 peripheral.
  * @param  Data£∫The data to transmit.
  * @retval None
  */
void UART4_Send_Byte(u8 Data) //∑¢ÀÕ“ª∏ˆ◊÷Ω⁄£ª
{
    USART_SendData(UART4, Data);
    while( USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET );
}
/**
  * @brief  Transmits string data through the UART4 peripheral.
  * @param  Data£∫The data to transmit.
  * @retval None
  */
void UART4_Send_String(u8 *Data) //∑¢ÀÕ◊÷∑˚¥Æ£ª
{
    while(*Data)
        UART4_Send_Byte(*Data++);
}
/**
  * @brief  UART4 interrupt handing function.
  * @param  None
  * @retval None
  */
void UART4_IRQHandler(void) //÷–∂œ¥¶¿Ì∫Ø ˝£ª
{		
    static u16	Wait_Syn = TRUE;
    static u8		Rx_num = 0;
    u8 data = 0;
		
    if(USART_GetITStatus(UART4, USART_IT_RXNE) == SET) //≈–∂œ «∑Ò∑¢…˙÷–∂œ£ª
    {
        if (Wait_Syn == TRUE)  				  //≈–∂œ∆ º±Í÷æ0xaa,0x55, «∑ÒÕÍ≥…
        {
            data = USART_ReceiveData(UART4); //Ω” ’ ˝æ›£ª
            if((data == 0xFF) || (data == 0xBF))
            {
                Wait_Syn = FALSE;
								Rx_num = 0;
								Uart4RxBuffer[Rx_num ++] = data;
            }
        }
        else
        {
            Uart4RxBuffer[Rx_num++] = USART_ReceiveData(UART4);
					
            if(Rx_num >= 5)
            {
								Uart4_ReceiveCommandProcess(Uart4RxBuffer);
								Rx_num = 0;
								Wait_Syn = TRUE;
            }
        }
    }
}

void UART4_Data_Transmit(void)
{
		USART_ITConfig(UART4, USART_IT_TXE,ENABLE); 
}

/*---------------------------- UART5 Mode Configuration -----------------------*/
/**
  * @brief  UART5≥ı ºªØ PC10,PC11
  * @param  baud: Set the communication baud rate
  * @retval None
  */
void UART5_Init(u32 baud)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD, ENABLE );
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE );

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; //UART5 TX£ª
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //∏¥”√Õ∆ÕÏ ‰≥ˆ£ª
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOC, &GPIO_InitStructure); //∂Àø⁄C£ª

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //UART5 RX£ª
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //∏°ø’ ‰»Î£ª
    GPIO_Init(GPIOD, &GPIO_InitStructure); //∂Àø⁄D£ª

    USART_InitStructure.USART_BaudRate = baud; //≤®Ãÿ¬ £ª
    USART_InitStructure.USART_WordLength = USART_WordLength_8b; // ˝æ›Œª8Œª£ª
    USART_InitStructure.USART_StopBits = USART_StopBits_1; //Õ£÷πŒª1Œª£ª
    USART_InitStructure.USART_Parity = USART_Parity_No ; //Œﬁ–£—ÈŒª£ª
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//Œﬁ”≤º˛¡˜øÿ£ª
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;// ’∑¢ƒ£ Ω£ª
    USART_Init(UART5, &USART_InitStructure);//≈‰÷√¥Æø⁄≤Œ ˝£ª


//    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //…Ë÷√÷–∂œ◊È2£¨0-3«¿’º”≈œ»º∂£¨0-3œÏ”¶”≈œ»º∂£ª

    NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn; //÷–∂œ∫≈£ª
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //«¿’º”≈œ»º∂£ª
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //œÏ”¶”≈œ»º∂£ª
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);


    USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);
    USART_Cmd(UART5, ENABLE); // πƒ‹¥Æø⁄£ª
}
/**
  * @brief  Transmits single data through the UART5 peripheral.
  * @param  Data£∫The data to transmit.
  * @retval None
  */
void UART5_Send_Byte(u8 Data) //∑¢ÀÕ“ª∏ˆ◊÷Ω⁄£ª
{
    USART_SendData(UART5, Data);
    while( USART_GetFlagStatus(UART5, USART_FLAG_TC) == RESET );
}
/**
* @brief ∑¢ÀÕ“ª¥Æµƒ ˝æ›
* @param
**len:  ˝æ›µƒ≥§∂»
**data:∑¢ÀÕ ˝æ›µƒ ◊µÿ÷∑
* @return None
* @details Ã◊”√¡ÀUSART5µƒ∑¢ÀÕ“ª∏ˆ◊÷Ω⁄µƒ∫Ø ˝
*/
void UART5_Send_Data(u8 len, u8 *data)
{
    u8 i = 0;
    for(i = 0; i < len; i++)
    {
        UART5_Send_Byte(*data++);
    }
}

/**
  * @brief  Transmits string data through the UART5 peripheral.
  * @param  Data£∫The data to transmit.
  * @retval None
  */
void UART5_Send_String(u8 *Data) //∑¢ÀÕ◊÷∑˚¥Æ£¨◊÷∑˚¥Æµƒƒ©Œ≤Œ™¡„
{
    while(*Data)
        UART5_Send_Byte(*Data++);
}
/**
  * @brief  UART5 interrupt handing function.
  * @param  None
  * @retval None
  */
void UART5_IRQHandler(void) //÷–∂œ¥¶¿Ì∫Ø ˝£ª
{
    static u8 	LastData = 0;
    static u16	Wait_Syn = TRUE;
    static u8		Rx_num = 0;
    static u8   Tx_num = 0;
    u8 data = 0;
		
    if(USART_GetITStatus(UART5, USART_IT_RXNE) == SET) //≈–∂œ «∑Ò∑¢…˙÷–∂œ£ª
    {
        if (Wait_Syn == TRUE)  				  //≈–∂œ∆ º±Í÷æ0xaa,0x55, «∑ÒÕÍ≥…
        {
            data = USART_ReceiveData(UART5); //Ω” ’ ˝æ›£ª
            if((LastData == 0xFD) && (data == 0xDF))
            {
                Wait_Syn = FALSE;
            }
            LastData = data;
        }
        else
        {
            Uart5RxBuffer[Rx_num++] = USART_ReceiveData(UART5);
            if(Rx_num >= Uart5RxBuffer[0] - 2)
            {
								Uart5_ReceiveCommandProcess(Uart5RxBuffer[0],Uart5RxBuffer+1);
								Rx_num = 0;
								LastData = 0;
								Wait_Syn = TRUE;
            }
        }
    }
		else if(USART_GetITStatus(UART5,USART_IT_TXE) != RESET)	//send data interupt
		{
				if(Tx_num < Uart5TxBuffer[2])
				{	
						USART_SendData(UART5,Uart5TxBuffer[Tx_num]);
						Tx_num++;	
				}
				else
				{	
						Tx_num=0;
						USART_ITConfig(UART5, USART_IT_TXE,DISABLE);
						if(Inquire_TXD_Handler(UART5))
						{
								UART5_TX_BUSY_FLAG = FALSE;
						}
				}
		}
}

/**
* @brief ¥Æø⁄Õ®–≈≥Ã–Ú
* @param
*len:  ˝æ›≥§∂»
*ID:   ˝æ›µƒ¿‡–Õ
*data[len]:Ω´“™∑¢ÀÕµƒ ˝æ›
*CHK: ˝æ›µƒ–£—È
* @return the return value
* @details a full description of what the function does
*/
void UART5_Data_Transmit(u8 len, u8 *data)
{

    data[0] = 0xFD;
    data[1] = 0xDF;
    data[2] = len;

		USART_ITConfig(UART5, USART_IT_TXE,ENABLE); 
   //UART5_Send_Data(len, data); /**Õ®π˝¥Æø⁄5∑¢ÀÕ ˝æ›**/

}
/**
 *@brief  ˝æ›µƒ∫Õ–£—È:CHK
 *@param len:    ˝æ›µƒ≥§∂»
 *@param array£∫Ω” ’µΩµƒ ˝æ›◊È
 *@return sum£∫ ˝æ›∫ÕŒ™¡„
 *@details ∑¢ÀÕµƒ ˝æ›∏Ò Ω£∫
  ===============================================================================================
    ±Í÷æ1   |     ±Í÷æ2     |    ˝æ›≥§∂»  |  Ω‚Œˆ∑Ω∑®  |     ∑¢ÀÕµƒ ˝æ›   |    ˝æ›µƒ∫Õ–£—È
  ===============================================================================================
    Flag1   |     Flag2     |     Len     |     ID     |      Data(0-9)   |        CHK
						|               |             |            |                  |
  -----------------------------------------------------------------------------------------------
    byte    |      byte     |      byte   |    byte    |     (1-10)bytes  |        byte
            |               |             |            |		        		  |
  -----------------------------------------------------------------------------------------------
 *@details –£—Èº∆À„π´ Ω£∫
	CHK = ~(Len+Id + Data[0-9])+1.
**/
u8 CalculateCheckSum(u8 len, u8 *array)
{
    u8 sum = len;
    u8 i;
    for(i = 0; i < len - KM_HEAD_LEN - 1; i++) // ˝æ›µƒ≥§∂»“∆≥˝flag1,flag2,ƒ©ŒªCHK
    {
        sum += array[i];
    }
    sum = ~sum + 1;

    return sum;
}
